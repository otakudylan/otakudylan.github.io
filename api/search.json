[{"id":"5f1dca04d0fa251a1a5a436620e41b44","title":"leetcode-非递归遍历二叉树","content":"&#x2F;&#x2F; 前序\nvector&lt;int&gt;preorderTraversal(TreeNode* root) &#123;\n\tvector&lt;int&gt; res;\n\tif (!root) return res;\n\tstack&lt;TreeNode*&gt; st;\n\tTreeNode* cur &#x3D; root;\n\twhile (!st.empty() || cur) &#123;\n\t\twhile (cur) &#123;\n\t\t\tres.push_back(cur-&gt;val);\n\t\t\tst.push(cur);\n\t\t\tcur &#x3D; cur-&gt;left;\n\t\t&#125;\n\t\tcur &#x3D; st.top();\n\t\tst.pop();\n\t\tcur &#x3D; cur-&gt;right;\n\t&#125;\n\treturn res;\n&#125;\n\n&#x2F;&#x2F; 中序\nvector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;\n\tvector&lt;int&gt; res;\n\tif (!root) return res;\n\tstack&lt;TreeNode*&gt; st;\n\tTreeNode* cur &#x3D; root;\n\twhile (!st.empty() || cur) &#123;\n\t\twhile (cur) &#123;\n\t\t\tst.push(cur);\n\t\t\tcur &#x3D; cur-&gt;left;\n\t\t&#125;\n\t\tcur &#x3D; st.top();\n\t\tst.pop();\n\t\tres.push_back(cur-&gt;val);\n\t\tcur &#x3D; cur-&gt;right;\n\t&#125;\n\treturn res;\n&#125;\n\n&#x2F;&#x2F; 后序\nvector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;\n\tvector&lt;int&gt; res;\n\tif (!root) return res;\n\tstack&lt;TreeNode*&gt; st;\n\tTreeNode* cur &#x3D; root;\n\twhile (!st.empty() || cur) &#123;\n\t\twhile (cur) &#123;\n\t\t\tres.insert(res.begin(), cur-&gt;val);\n\t\t\tst.push(cur);\n\t\t\tcur &#x3D; cur-&gt;right;\n\t\t&#125;\n\t\tcur &#x3D; st.top();\n\t\tst.pop();\n\t\tcur &#x3D; cur-&gt;left;\n\t&#125;\n\treturn res;\n&#125;","slug":"leetcode-非递归遍历二叉树","date":"2022-01-05T16:36:31.000Z","categories_index":"数据结构与算法","tags_index":"leetcode,二叉树","author_index":"Dylan"},{"id":"52d648ff3e6bea3e12a567ee8b6734e9","title":"类的特殊非静态成员函数","content":"类里面存在六个特种成员函数\n默认构造函数 一般形式：Obj();\n拷贝构造函数 一般形式：Obj(const Obj&amp;);\n拷贝赋值运算符一般形式：Obj&amp; operator=(const Obj&amp;);或Obj&amp; operator=(Obj);\n移动构造函数一般形式：Obj(Obj&amp;&amp;);\n移动赋值运算符一般形式：Obj&amp; operator=(Obj&amp;&amp;);\n析构函数一般形式：~Obj();\n\n特点：\n\nC++会隐式声明和默认提供。但是默认提供存在一定规则。\n成员函数模板在任何情况下都不会抑制这些函数的隐式声明和默认提供。\n\n一般规则\n当用户不提供其他构造函数（包括拷贝构造和移动构造）时，默认构造函数会被隐式声明、默认提供。\n当用户不提供拷贝构造函数时，拷贝构造函数会被隐式声明、默认提供。\n当用户不提供拷贝赋值运算符时，拷贝赋值运算符会被隐式声明、默认提供。\n当用户不提供析构函数时，析构函数会被隐式声明、默认提供。\n\n重要规则\n\n拷贝构造函数：当用户声明移动构造函数和移动赋值运算符时，隐式声明的拷贝构造函数会被删除。当已经存在拷贝赋值运算符或析构函数时，不建议生成拷贝构造函数。\n拷贝赋值运算符：当用户声明移动构造函数和移动赋值运算符时，隐式声明的拷贝赋值运算符会被删除。当已经存在拷贝构造函数或析构函数时，不建议生成拷贝赋值运算符。\n移动构造函数：当用户不声明除默认构造函数外的任意一个特殊成员函数（包含”= delete“的情况）时，移动构造函数会被隐式声明、默认提供。\n移动赋值运算符：当用户不声明除默认构造函数外的任意一个特殊成员函数（包含”= delete“的情况）时，移动赋值运算符会被隐式声明、默认提供。\n\n惯用法\n默认构造函数：在用户提供其他构造函数时，使用”= default“要求编译器提供默认版本。\n拷贝构造函数：使用”= delete“要求编译器删除默认版本，防止对象被意外复制。\n拷贝赋值运算符：和拷贝构造函数一起定义或被删除。\n移动构造函数：要么由编译器提供隐式声明的默认版本，要么由用户自行提供；一般不需要使用”= default“或”= delete“。\n移动赋值运算符：要么由编译器提供隐式声明的默认版本，要么由用户自行提供；一般不需要使用”= default“或”= delete“。\n析构函数：对于面向对象继承树的基类，使用”virtual ~Obj() = default;“。三/五法则\n\nC++98三法则：\n\n如果一个类需要自定义析构函数，几乎可以肯定它肯定也需要自定义拷贝构造函数和拷贝赋值运算符。\n需要拷贝操作的类也需要赋值操作，反之亦然。\n无论是需要拷贝构造函数还是需要拷贝赋值运算符都不必然意味着也需要析构函数。\n\nC++11五法则：\n\n如果一个类定义了任何一个拷贝操作，他就应该定义所有五个操作（拷贝、拷贝赋值、移动、移动赋值、析构）。\n因为用户定义的析构函数、复制构造函数或复制赋值运算符的存在会阻止移动构造函数和移动赋值运算符的隐式定义，所以任何想要移动语义的类必须声明全部五个特殊成员函数：\n\n参考：《C++ Primer》13.1.4节（第447页）和13.6.2节（第478页）三/五/零法则.\n","slug":"Cpp-类的特殊非静态成员函数","date":"2022-01-05T13:04:21.000Z","categories_index":"C++","tags_index":"C++,成员函数,默认提供","author_index":"Dylan"},{"id":"f7cb7d701b00fc37f4d06f66b3862db0","title":"auto类型推导","content":"auto类型推导一般情况，auto类型推导和模板类型推导是一模一样的，但是auto类型推导会假定用大括号括起来的初始化表达式代表一个std::initializer_list,而这种情况下，形参为T的模板无法推导T的类型。\n一般情况auto类型推导和模板类型推导可以建立一一映射：\n模板类型推导形参T&amp;：\ntemplate&lt;typename T&gt;\nvoid f(T&amp; param);\n\nf(expr);\nauto类型推导对应的形式：\nauto&amp; param &#x3D; expr; &#x2F;&#x2F; auto这里和模板类型推导的T对应。\n\n模板类型推导形参const T&amp;：\ntemplate&lt;typename T&gt;\nvoid f(const T&amp; param);\n\nf(expr);\nauto类型推导对应的形式：\nconst auto&amp; param &#x3D; expr; \n\n模板类型推导形参万能引用T&amp;&amp;：\ntemplate&lt;typename T&gt;\nvoid f(T&amp;&amp; param);\n\nf(expr);\nauto类型推导对应的形式：\nauto&amp;&amp; param &#x3D; expr; \n\n特殊情况auto类型推导会假定用大括号括起来的初始化表达式代表一个std::initializer_list,而这种情况下，形参为T的模板无法推导T的类型。auto类型推导为std::initializer_list。\nauto x &#x3D; &#123; 1,2,3,4 &#125;;\ncout &lt;&lt; &quot;x&#39;s type &#x3D;\\t&quot;\n    &lt;&lt; type_id_with_cvr&lt;decltype(x)&gt;().pretty_name()\n    &lt;&lt; endl;\n&#x2F;&#x2F; 输出:\n&#x2F;&#x2F; x&#39;s type &#x3D;      class std::initializer_list&lt;int&gt;\n模板类型推导，编译报错。\n#include &lt;boost&#x2F;type_index.hpp&gt;\n#include &lt;iostream&gt;\n\nusing std::cout;\nusing std::endl;\nusing boost::typeindex::type_id_with_cvr;\n\ntemplate&lt;typename T&gt;\nvoid f(T param) &#123;\n\t\n\tcout &lt;&lt; &quot;匹配形参为T的模板函数:&quot; &lt;&lt; endl;\n\t&#x2F;&#x2F; 显示T的类型\n\tcout &lt;&lt; &quot;T&#39;s type &#x3D;\\t&quot;\n\t\t&lt;&lt; type_id_with_cvr&lt;T&gt;().pretty_name()\n\t\t&lt;&lt; endl;\n\n\t&#x2F;&#x2F; 显示param的类型(ParamType)\n\tcout &lt;&lt; &quot;param&#39;s type &#x3D;\\t&quot;\n\t\t&lt;&lt; type_id_with_cvr&lt;decltype(param)&gt;().pretty_name()\n\t\t&lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\tf(&#123; 1,2,3,4 &#125;);\n&#125;\n\n&#x2F;*\n编译报错：\nerror C2672: &#39;f&#39;: no matching overloaded function found\nerror C2783: &#39;void f(T)&#39;: could not deduce template argument for &#39;T&#39;\nmessage : see declaration of &#39;f&#39;\n*&#x2F;\nC++14的两种特殊情况C++14允许使用auto来说明函数返回值需要推导，lambda式也会在形参声明中用到auto，但是这两种情况是使用模板类型推导，也即不支持推导类型为std::initializer_list。这两种情况编译不过：\nauto createInitList() &#123;\n    return &#123;1, 2, 3&#125;; \n&#125;\n&#x2F;*\n错误：\nerror C3108: cannot deduce a type as an initializer list is not an expression\nerror C2440: &#39;return&#39;: cannot convert from &#39;initializer list&#39; to &#39;auto&#39;\n*&#x2F;\nstd::vector&lt;int&gt; v;\nauto resetV &#x3D; [&amp;v](const auto&amp; newValue) &#123; v &#x3D; newValue; &#125;;\nresetV(&#123;1, 2, 3&#125;);\n&#x2F;*\n错误：\nerror C2672: &#39;operator __surrogate_func&#39;: no matching overloaded function found\nerror C2783: &#39;auto main::&lt;lambda_54107a7a2c8ad00836a27f4efe579f91&gt;::operator ()(const _T1 &amp;) const&#39;: could not deduce template argument for &#39;_T1&#39;\n*&#x2F;","slug":"Cpp-auto类型推导","date":"2022-01-04T15:25:31.000Z","categories_index":"C++","tags_index":"C++,auto,类型推导","author_index":"Dylan"},{"id":"74bd91e54bf2c495459c34d0d276fa06","title":"模板类型推导","content":"类型推导C++是静态类型语言，所有的类型推导都是在编译期间完成的。\n模板类型推导函数模板调用的一般形式为：\ntemplate&lt;typename T&gt;\nvoid f(ParamType param);\n\nf(expr);\n类型推导一共分三种一般情况和两种特殊情况\n情况1：ParamType是个指针或引用，但不是万能引用&#x2F;&#x2F; ParamType为引用\ntemplate&lt;typename T&gt;\nvoid f(T&amp; param);\n\n&#x2F;&#x2F; ParamType为引用\ntemplate&lt;typename T&gt;\nvoid f(T* param);\n\nf(expr);\n\n这种情况下，如果expr具有引用类型，先将引用类型忽略，再执行模式匹配。\n\nParamType为引用还是指针，其运行方式是一样的。\n#include &lt;boost&#x2F;type_index.hpp&gt;\n#include &lt;iostream&gt;\n\ntemplate&lt;typename T&gt;\nvoid f(T&amp; param) &#123;\n\tusing std::cout;\n\tusing std::endl;\n\tusing boost::typeindex::type_id_with_cvr;\n\n\tcout &lt;&lt; &quot;匹配形参为T&amp;的模板函数:&quot; &lt;&lt; endl;\n\t&#x2F;&#x2F; 显示T的类型\n\tcout &lt;&lt; &quot;T&#39;s type &#x3D;\\t&quot;\n\t\t&lt;&lt; type_id_with_cvr&lt;T&gt;().pretty_name()\n\t\t&lt;&lt; endl;\n\n\t&#x2F;&#x2F; 显示param的类型(ParamType)\n\tcout &lt;&lt; &quot;param&#39;s type &#x3D;\\t&quot;\n\t\t&lt;&lt; type_id_with_cvr&lt;decltype(param)&gt;().pretty_name()\n\t\t&lt;&lt; endl;\n&#125;\n\ntemplate&lt;typename T&gt;\nvoid f(T* param) &#123;\n\tusing std::cout;\n\tusing std::endl;\n\tusing boost::typeindex::type_id_with_cvr;\n\n\tcout &lt;&lt; &quot;匹配形参为T*的模板函数:&quot; &lt;&lt; endl;\n\t&#x2F;&#x2F; 显示T的类型\n\tcout &lt;&lt; &quot;T&#39;s type &#x3D;\\t&quot;\n\t\t&lt;&lt; type_id_with_cvr&lt;T&gt;().pretty_name()\n\t\t&lt;&lt; endl;\n\n\t&#x2F;&#x2F; 显示param的类型(ParamType)\n\tcout &lt;&lt; &quot;param&#39;s type &#x3D;\\t&quot;\n\t\t&lt;&lt; type_id_with_cvr&lt;decltype(param)&gt;().pretty_name()\n\t\t&lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\tint x &#x3D; 27;\n\tconst int cx &#x3D; x;\n\tconst int &amp;rx &#x3D; x;\n\tconst int *px &#x3D; &amp;x;\n\n\tf(x);\n\tf(cx);\n\tf(rx);\n\tf(&amp;x);\n\tf(px);\n&#125;\n\n&#x2F;*\n执行结果(int const 和const int 没有区别)\n匹配形参为T&amp;的模板函数:\nT&#39;s type &#x3D;      int\nparam&#39;s type &#x3D;  int &amp;\n匹配形参为T&amp;的模板函数 :\nT&#39;s type &#x3D;      int const\nparam&#39;s type &#x3D;  int const &amp;\n匹配形参为T&amp;的模板函数 :\nT&#39;s type &#x3D;      int const\nparam&#39;s type &#x3D;  int const &amp;\n匹配形参为T*的模板函数 :\nT&#39;s type &#x3D;      int\nparam&#39;s type &#x3D;  int *\n匹配形参为T*的模板函数 :\nT&#39;s type &#x3D;      int const\nparam&#39;s type &#x3D;  int const *\n*&#x2F;\n\n情况2：ParamType是万能引用该情况较为复杂，这里简要给出大纲，以后再详细讨论。\ntemplate&lt;typename T&gt;\nvoid f(T&amp;&amp; param);\n\nf(expr);\n\n如果expr是左值，T和ParamType都会推导为左值引用。\n如果expr是右值，T推导为expr的类型，ParamType推导为右值引用。#include &lt;boost&#x2F;type_index.hpp&gt;\n#include &lt;iostream&gt;\n\ntemplate&lt;typename T&gt;\nvoid f(T&amp;&amp; param) &#123;\n\tusing std::cout;\n\tusing std::endl;\n\tusing boost::typeindex::type_id_with_cvr;\n\n\tcout &lt;&lt; &quot;匹配形参为T&amp;&amp;的模板函数:&quot; &lt;&lt; endl;\n\t&#x2F;&#x2F; 显示T的类型\n\tcout &lt;&lt; &quot;T&#39;s type &#x3D;\\t&quot;\n\t\t&lt;&lt; type_id_with_cvr&lt;T&gt;().pretty_name()\n\t\t&lt;&lt; endl;\n\n\t&#x2F;&#x2F; 显示param的类型(ParamType)\n\tcout &lt;&lt; &quot;param&#39;s type &#x3D;\\t&quot;\n\t\t&lt;&lt; type_id_with_cvr&lt;decltype(param)&gt;().pretty_name()\n\t\t&lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\tint x &#x3D; 27;\n\tconst int cx &#x3D; x;\n\tconst int &amp;rx &#x3D; x;\n\tconst int *px &#x3D; &amp;x;\n\n\tf(x);\n\tf(cx);\n\tf(rx);\n\tf(&amp;x);\n\tf(px);\n\tf(27);\n&#125;\n\n&#x2F;*\n执行结果:\n匹配形参为T&amp;&amp;的模板函数:\nT&#39;s type &#x3D;      int &amp;\nparam&#39;s type &#x3D;  int &amp;\n匹配形参为T&amp;&amp;的模板函数:\nT&#39;s type &#x3D;      int const &amp;\nparam&#39;s type &#x3D;  int const &amp;\n匹配形参为T&amp;&amp;的模板函数:\nT&#39;s type &#x3D;      int const &amp;\nparam&#39;s type &#x3D;  int const &amp;\n匹配形参为T&amp;&amp;的模板函数:\nT&#39;s type &#x3D;      int *\nparam&#39;s type &#x3D;  int * &amp;&amp;\n匹配形参为T&amp;&amp;的模板函数:\nT&#39;s type &#x3D;      int const * &amp;\nparam&#39;s type &#x3D;  int const * &amp;\n匹配形参为T&amp;&amp;的模板函数:\nT&#39;s type &#x3D;      int\nparam&#39;s type &#x3D;  int &amp;&amp;\n*&#x2F;\n\n情况3：ParamType既非指针也非引用\n若expr具有引用类型，则忽略引用部分。\n若expr是个volatile对象，则忽略volatile部分。\n若expr是个被const修饰的引用，忽略const部分。\n若expr是个被const修饰的指针，忽略顶层const部分。（const int是底层const,即指向常量的指针； int const是顶层const，即指针常量)#include &lt;boost&#x2F;type_index.hpp&gt;\n#include &lt;iostream&gt;\n\ntemplate&lt;typename T&gt;\nvoid f(T param) &#123;\n\tusing std::cout;\n\tusing std::endl;\n\tusing boost::typeindex::type_id_with_cvr;\n\n\tcout &lt;&lt; &quot;匹配形参为T的模板函数:&quot; &lt;&lt; endl;\n\t&#x2F;&#x2F; 显示T的类型\n\tcout &lt;&lt; &quot;T&#39;s type &#x3D;\\t&quot;\n\t\t&lt;&lt; type_id_with_cvr&lt;T&gt;().pretty_name()\n\t\t&lt;&lt; endl;\n\n\t&#x2F;&#x2F; 显示param的类型(ParamType)\n\tcout &lt;&lt; &quot;param&#39;s type &#x3D;\\t&quot;\n\t\t&lt;&lt; type_id_with_cvr&lt;decltype(param)&gt;().pretty_name()\n\t\t&lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\tint x &#x3D; 27;\n\tconst int cx &#x3D; x;\n\tconst int &amp;rx &#x3D; x;\n\tconst int *pa &#x3D; &amp;x; &#x2F;&#x2F; 底层const\n\tint* const pb &#x3D; &amp;x; &#x2F;&#x2F; 顶层const\n\n\tf(x);\n\tf(cx);\n\tf(rx);\n\tf(pa);\n\tf(pb);\n&#125;\n\n&#x2F;*\n执行结果:\n匹配形参为T的模板函数:\nT&#39;s type &#x3D;      int\nparam&#39;s type &#x3D;  int\n匹配形参为T的模板函数:\nT&#39;s type &#x3D;      int\nparam&#39;s type &#x3D;  int\n匹配形参为T的模板函数:\nT&#39;s type &#x3D;      int\nparam&#39;s type &#x3D;  int\n匹配形参为T的模板函数:\nT&#39;s type &#x3D;      int const *\nparam&#39;s type &#x3D;  int const *\n匹配形参为T的模板函数: \nT&#39;s type &#x3D;      int *\nparam&#39;s type &#x3D;  int *  &#x2F;&#x2F; 指针本身的常量属性被忽略了\n*&#x2F;\n\n特殊情况1：数组实参\n当数组传给按值形参的模板时，数组会推导为指针。\n当数组传给引用形参的模板时，数组会推导为数组类型。\n\n形参为值传递的模板：\n#include &lt;boost&#x2F;type_index.hpp&gt;\n#include &lt;iostream&gt;\n\ntemplate&lt;typename T&gt;\nvoid f(T param) &#123;\n\tusing std::cout;\n\tusing std::endl;\n\tusing boost::typeindex::type_id_with_cvr;\n\n\tcout &lt;&lt; &quot;匹配形参为T的模板函数:&quot; &lt;&lt; endl;\n\t&#x2F;&#x2F; 显示T的类型\n\tcout &lt;&lt; &quot;T&#39;s type &#x3D;\\t&quot;\n\t\t&lt;&lt; type_id_with_cvr&lt;T&gt;().pretty_name()\n\t\t&lt;&lt; endl;\n\n\t&#x2F;&#x2F; 显示param的类型(ParamType)\n\tcout &lt;&lt; &quot;param&#39;s type &#x3D;\\t&quot;\n\t\t&lt;&lt; type_id_with_cvr&lt;decltype(param)&gt;().pretty_name()\n\t\t&lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\tint keyVals[] &#x3D; &#123; 1,3,5,7,9 &#125;;\n\n\tf(keyVals);\n&#125;\n\n&#x2F;*\n匹配形参为T的模板函数:\nT&#39;s type &#x3D;      int *\nparam&#39;s type &#x3D;  int *\n*&#x2F;\n形参为引用传递的模板：\n#include &lt;boost&#x2F;type_index.hpp&gt;\n#include &lt;iostream&gt;\n\ntemplate&lt;typename T&gt;\nvoid f(T&amp; param) &#123;\n\tusing std::cout;\n\tusing std::endl;\n\tusing boost::typeindex::type_id_with_cvr;\n\n\tcout &lt;&lt; &quot;匹配形参为T&amp;的模板函数:&quot; &lt;&lt; endl;\n\t&#x2F;&#x2F; 显示T的类型\n\tcout &lt;&lt; &quot;T&#39;s type &#x3D;\\t&quot;\n\t\t&lt;&lt; type_id_with_cvr&lt;T&gt;().pretty_name()\n\t\t&lt;&lt; endl;\n\n\t&#x2F;&#x2F; 显示param的类型(ParamType)\n\tcout &lt;&lt; &quot;param&#39;s type &#x3D;\\t&quot;\n\t\t&lt;&lt; type_id_with_cvr&lt;decltype(param)&gt;().pretty_name()\n\t\t&lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\tint keyVals[] &#x3D; &#123; 1,3,5,7,9 &#125;;\n\n\tf(keyVals);\n&#125;\n\n&#x2F;*\n匹配形参为T&amp;的模板函数:\nT&#39;s type &#x3D;      int [5]\nparam&#39;s type &#x3D;  int (&amp;)[5]\n*&#x2F;\n可利用引用传递保留数组属性这一点，结合非类型模板参数，推导出数组元素个数。\ntemplate&lt;typename T, std::size_t N&gt;\nconstexpr std::size_t arraySize(T(&amp;)[N]) noexcept &#123;\n\treturn N;\n&#125;\n\nint main() &#123;\n\tusing std::cout;\n\tusing std::endl;\n\tint keyVals[] &#x3D; &#123; 1,3,5,7,9 &#125;;\n\n\tcout &lt;&lt; arraySize(keyVals) &lt;&lt; endl;\n&#125;\n\n&#x2F;*\n执行结果：\n5\n*&#x2F;\n特殊情况2：函数实参\n当函数传给按值或引用形参的模板时，函数会退化为函数指针或函数引用。#include &lt;boost&#x2F;type_index.hpp&gt;\n#include &lt;iostream&gt;\n\nvoid someFunc(int, double) &#123;&#125;\n\ntemplate&lt;typename T&gt;\nvoid f1(T param) &#123;\n\tusing std::cout;\n\tusing std::endl;\n\tusing boost::typeindex::type_id_with_cvr;\n\n\tcout &lt;&lt; &quot;匹配形参为T的模板函数:&quot; &lt;&lt; endl;\n\t&#x2F;&#x2F; 显示T的类型\n\tcout &lt;&lt; &quot;T&#39;s type &#x3D;\\t&quot;\n\t\t&lt;&lt; type_id_with_cvr&lt;T&gt;().pretty_name()\n\t\t&lt;&lt; endl;\n\n\t&#x2F;&#x2F; 显示param的类型(ParamType)\n\tcout &lt;&lt; &quot;param&#39;s type &#x3D;\\t&quot;\n\t\t&lt;&lt; type_id_with_cvr&lt;decltype(param)&gt;().pretty_name()\n\t\t&lt;&lt; endl;\n&#125;\n\ntemplate&lt;typename T&gt;\nvoid f2(T&amp; param) &#123;\n\tusing std::cout;\n\tusing std::endl;\n\tusing boost::typeindex::type_id_with_cvr;\n\n\tcout &lt;&lt; &quot;匹配形参为T&amp;的模板函数:&quot; &lt;&lt; endl;\n\t&#x2F;&#x2F; 显示T的类型\n\tcout &lt;&lt; &quot;T&#39;s type &#x3D;\\t&quot;\n\t\t&lt;&lt; type_id_with_cvr&lt;T&gt;().pretty_name()\n\t\t&lt;&lt; endl;\n\n\t&#x2F;&#x2F; 显示param的类型(ParamType)\n\tcout &lt;&lt; &quot;param&#39;s type &#x3D;\\t&quot;\n\t\t&lt;&lt; type_id_with_cvr&lt;decltype(param)&gt;().pretty_name()\n\t\t&lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\tf1(someFunc);\n\tf2(someFunc);\n&#125;\n\n&#x2F;*\n匹配形参为T的模板函数:\nT&#39;s type &#x3D;      void (__cdecl*)(int,double)\nparam&#39;s type &#x3D;  void (__cdecl*)(int,double)\n匹配形参为T&amp;的模板函数:\nT&#39;s type &#x3D;      void __cdecl(int,double)\nparam&#39;s type &#x3D;  void (__cdecl&amp;)(int,double)\n*&#x2F;\n\n\n","slug":"Cpp-模板类型推导","date":"2022-01-03T12:32:36.000Z","categories_index":"C++","tags_index":"C++,template,类型推导","author_index":"Dylan"},{"id":"28e8be842274bcbbc24c76b0de30d4ae","title":"UE4-GAS","content":"AbilitySystemComponentASC提供了三种不同的复制模式，用以复制GameplayEffects、GameplayTags 和 GameplayCues，分别是Full, Mixed, 和 Minimal。Attributes是由 AttributeSet复制。\n\n\n\n复制模式\n使用场景\n描述\n\n\n\nFull\n单人\nGameplayEffect会被复制到所有客户端。\n\n\nMixed\n多人,玩家控制的Actors\nGameplayEffects仅被复制到拥有者的客户端. 仅 GameplayTags 和 GameplayCues 会被复制到所有客户端\n\n\nMinimal\n多人, AI控制的Actors\nGameplayEffects不会复制到任何客户端. 仅 GameplayTags 和 GameplayCues 会被复制到所有客户端\n\n\n注意： Mixed 复制模式要求OwnerActor的 Owner必须是Controller。 PlayerState的 Owner默认是Controller，但是Character不是。如果使用Mixed复制模式的OwnerActor不是PlayerState那么你需要在OwnerActor上调用SetOwner()并传递一个有效的Controller。（不过从4.24开始, PossessedBy() 会为Pawn设置一个新的Controller。）\nASC需要有OwnerActor和AvatarActor进行初始化，而且必须在服务器和客户端都要完成初始化。\n对于玩家控制的角色，ASC存在于Pawn中，我通常在Pawn的 PossessedBy()方法中完成ASC在服务器端的初始化，在PlayerController的AcknowledgePawn()方法中完成ASC在客户端的初始化。\n对于玩家控制的角色，ASC存在于PlayerState中，我通常在Pawn 的PossessedBy() 方法中完成ASC在服务器端的初始化（这一点与上述相同），在 Pawn的 OnRep_PlayerState()方法中完成ASC在客户端的初始化（这将确保PlayerState在客户端已存在）\nGameplayTags(前面多花精力想好结构和名字，这玩意尽可能的不要在后面改)多个GameplayTags可以被存储到FGameplayTagContainer中。强烈建议使用GameplayTagContainer而不是TArray&lt;FGameplayTag&gt;，因为GameplayTagContainers添加了一些例其高效的魔法。 标签是标准的FNames，在FGameplayTagContainers中他们可以被高效的打包在一起以完成网络复制，当然需要先在项目设置中开启Fast Replication。Fast Replication要求服务器和客户端拥有相同的GameplayTags列表。为了遍历GameplayTagContainers也可以返回一个TArray&lt;FGameplayTag&gt;。\nASC 也可以添加不会被复制并且需要手动管理的LooseGameplayTags。\n","slug":"UE4-GAS","date":"2022-01-03T08:02:28.000Z","categories_index":"UE4","tags_index":"UE4,GAS","author_index":"Dylan"}]