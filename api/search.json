[{"id":"74bd91e54bf2c495459c34d0d276fa06","title":"模板类型推导","content":"类型推导C++是静态类型语言，所有的类型推导都是在编译期间完成的。\n模板类型推导函数模板调用的一般形式为：\ntemplate&lt;typename T&gt;\nvoid f(ParamType param);\n\nf(expr);\n类型推导一共分三种一般情况和两种特殊情况\n情况1：ParamType是个指针或引用，但不是万能引用&#x2F;&#x2F; ParamType为引用\ntemplate&lt;typename T&gt;\nvoid f(T&amp; param);\n\n&#x2F;&#x2F; ParamType为引用\ntemplate&lt;typename T&gt;\nvoid f(T* param);\n\nf(expr);\n\n这种情况下，如果expr具有引用类型，先将引用类型忽略，再执行模式匹配。\n\nParamType为引用还是指针，其运行方式是一样的。\n#include &lt;boost&#x2F;type_index.hpp&gt;\n#include &lt;iostream&gt;\n\ntemplate&lt;typename T&gt;\nvoid f(T&amp; param) &#123;\n\tusing std::cout;\n\tusing std::endl;\n\tusing boost::typeindex::type_id_with_cvr;\n\n\tcout &lt;&lt; &quot;匹配形参为T&amp;的模板函数:&quot; &lt;&lt; endl;\n\t&#x2F;&#x2F; 显示T的类型\n\tcout &lt;&lt; &quot;T&#39;s type &#x3D;\\t&quot;\n\t\t&lt;&lt; type_id_with_cvr&lt;T&gt;().pretty_name()\n\t\t&lt;&lt; endl;\n\n\t&#x2F;&#x2F; 显示param的类型(ParamType)\n\tcout &lt;&lt; &quot;param&#39;s type &#x3D;\\t&quot;\n\t\t&lt;&lt; type_id_with_cvr&lt;decltype(param)&gt;().pretty_name()\n\t\t&lt;&lt; endl;\n&#125;\n\ntemplate&lt;typename T&gt;\nvoid f(T* param) &#123;\n\tusing std::cout;\n\tusing std::endl;\n\tusing boost::typeindex::type_id_with_cvr;\n\n\tcout &lt;&lt; &quot;匹配形参为T*的模板函数:&quot; &lt;&lt; endl;\n\t&#x2F;&#x2F; 显示T的类型\n\tcout &lt;&lt; &quot;T&#39;s type &#x3D;\\t&quot;\n\t\t&lt;&lt; type_id_with_cvr&lt;T&gt;().pretty_name()\n\t\t&lt;&lt; endl;\n\n\t&#x2F;&#x2F; 显示param的类型(ParamType)\n\tcout &lt;&lt; &quot;param&#39;s type &#x3D;\\t&quot;\n\t\t&lt;&lt; type_id_with_cvr&lt;decltype(param)&gt;().pretty_name()\n\t\t&lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\tint x &#x3D; 27;\n\tconst int cx &#x3D; x;\n\tconst int &amp;rx &#x3D; x;\n\tconst int *px &#x3D; &amp;x;\n\n\tf(x);\n\tf(cx);\n\tf(rx);\n\tf(&amp;x);\n\tf(px);\n&#125;\n\n&#x2F;*\n执行结果(int const 和const int 没有区别)\n匹配形参为T&amp;的模板函数:\nT&#39;s type &#x3D;      int\nparam&#39;s type &#x3D;  int &amp;\n匹配形参为T&amp;的模板函数 :\nT&#39;s type &#x3D;      int const\nparam&#39;s type &#x3D;  int const &amp;\n匹配形参为T&amp;的模板函数 :\nT&#39;s type &#x3D;      int const\nparam&#39;s type &#x3D;  int const &amp;\n匹配形参为T*的模板函数 :\nT&#39;s type &#x3D;      int\nparam&#39;s type &#x3D;  int *\n匹配形参为T*的模板函数 :\nT&#39;s type &#x3D;      int const\nparam&#39;s type &#x3D;  int const *\n*&#x2F;\n\n情况2：ParamType是万能引用该情况较为复杂，这里简要给出大纲，以后再详细讨论。\ntemplate&lt;typename T&gt;\nvoid f(T&amp;&amp; param);\n\nf(expr);\n\n如果expr是左值，T和ParamType都会推导为左值引用。\n如果expr是右值，T推导为expr的类型，ParamType推导为右值引用。#include &lt;boost&#x2F;type_index.hpp&gt;\n#include &lt;iostream&gt;\n\ntemplate&lt;typename T&gt;\nvoid f(T&amp;&amp; param) &#123;\n\tusing std::cout;\n\tusing std::endl;\n\tusing boost::typeindex::type_id_with_cvr;\n\n\tcout &lt;&lt; &quot;匹配形参为T&amp;&amp;的模板函数:&quot; &lt;&lt; endl;\n\t&#x2F;&#x2F; 显示T的类型\n\tcout &lt;&lt; &quot;T&#39;s type &#x3D;\\t&quot;\n\t\t&lt;&lt; type_id_with_cvr&lt;T&gt;().pretty_name()\n\t\t&lt;&lt; endl;\n\n\t&#x2F;&#x2F; 显示param的类型(ParamType)\n\tcout &lt;&lt; &quot;param&#39;s type &#x3D;\\t&quot;\n\t\t&lt;&lt; type_id_with_cvr&lt;decltype(param)&gt;().pretty_name()\n\t\t&lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\tint x &#x3D; 27;\n\tconst int cx &#x3D; x;\n\tconst int &amp;rx &#x3D; x;\n\tconst int *px &#x3D; &amp;x;\n\n\tf(x);\n\tf(cx);\n\tf(rx);\n\tf(&amp;x);\n\tf(px);\n\tf(27);\n&#125;\n\n&#x2F;*\n执行结果:\n匹配形参为T&amp;&amp;的模板函数:\nT&#39;s type &#x3D;      int &amp;\nparam&#39;s type &#x3D;  int &amp;\n匹配形参为T&amp;&amp;的模板函数:\nT&#39;s type &#x3D;      int const &amp;\nparam&#39;s type &#x3D;  int const &amp;\n匹配形参为T&amp;&amp;的模板函数:\nT&#39;s type &#x3D;      int const &amp;\nparam&#39;s type &#x3D;  int const &amp;\n匹配形参为T&amp;&amp;的模板函数:\nT&#39;s type &#x3D;      int *\nparam&#39;s type &#x3D;  int * &amp;&amp;\n匹配形参为T&amp;&amp;的模板函数:\nT&#39;s type &#x3D;      int const * &amp;\nparam&#39;s type &#x3D;  int const * &amp;\n匹配形参为T&amp;&amp;的模板函数:\nT&#39;s type &#x3D;      int\nparam&#39;s type &#x3D;  int &amp;&amp;\n*&#x2F;\n\n情况3：ParamType既非指针也非引用\n若expr具有引用类型，则忽略引用部分。\n若expr是个volatile对象，则忽略volatile部分。\n若expr是个被const修饰的引用，忽略const部分。\n若expr是个被const修饰的指针，忽略顶层const部分。（const int是底层const,即指向常量的指针； int const是顶层const，即指针常量)#include &lt;boost&#x2F;type_index.hpp&gt;\n#include &lt;iostream&gt;\n\ntemplate&lt;typename T&gt;\nvoid f(T param) &#123;\n\tusing std::cout;\n\tusing std::endl;\n\tusing boost::typeindex::type_id_with_cvr;\n\n\tcout &lt;&lt; &quot;匹配形参为T的模板函数:&quot; &lt;&lt; endl;\n\t&#x2F;&#x2F; 显示T的类型\n\tcout &lt;&lt; &quot;T&#39;s type &#x3D;\\t&quot;\n\t\t&lt;&lt; type_id_with_cvr&lt;T&gt;().pretty_name()\n\t\t&lt;&lt; endl;\n\n\t&#x2F;&#x2F; 显示param的类型(ParamType)\n\tcout &lt;&lt; &quot;param&#39;s type &#x3D;\\t&quot;\n\t\t&lt;&lt; type_id_with_cvr&lt;decltype(param)&gt;().pretty_name()\n\t\t&lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\tint x &#x3D; 27;\n\tconst int cx &#x3D; x;\n\tconst int &amp;rx &#x3D; x;\n\tconst int *pa &#x3D; &amp;x; &#x2F;&#x2F; 底层const\n\tint* const pb &#x3D; &amp;x; &#x2F;&#x2F; 顶层const\n\n\tf(x);\n\tf(cx);\n\tf(rx);\n\tf(pa);\n\tf(pb);\n&#125;\n\n&#x2F;*\n执行结果:\n匹配形参为T的模板函数:\nT&#39;s type &#x3D;      int\nparam&#39;s type &#x3D;  int\n匹配形参为T的模板函数:\nT&#39;s type &#x3D;      int\nparam&#39;s type &#x3D;  int\n匹配形参为T的模板函数:\nT&#39;s type &#x3D;      int\nparam&#39;s type &#x3D;  int\n匹配形参为T的模板函数:\nT&#39;s type &#x3D;      int const *\nparam&#39;s type &#x3D;  int const *\n匹配形参为T的模板函数: \nT&#39;s type &#x3D;      int *\nparam&#39;s type &#x3D;  int *  &#x2F;&#x2F; 指针本身的常量属性被忽略了\n*&#x2F;\n\n特殊情况1：数组实参\n当数组传给按值形参的模板时，数组会推导为指针。\n当数组传给引用形参的模板时，数组会推导为数组类型。\n\n形参为值传递的模板：\n#include &lt;boost&#x2F;type_index.hpp&gt;\n#include &lt;iostream&gt;\n\ntemplate&lt;typename T&gt;\nvoid f(T param) &#123;\n\tusing std::cout;\n\tusing std::endl;\n\tusing boost::typeindex::type_id_with_cvr;\n\n\tcout &lt;&lt; &quot;匹配形参为T的模板函数:&quot; &lt;&lt; endl;\n\t&#x2F;&#x2F; 显示T的类型\n\tcout &lt;&lt; &quot;T&#39;s type &#x3D;\\t&quot;\n\t\t&lt;&lt; type_id_with_cvr&lt;T&gt;().pretty_name()\n\t\t&lt;&lt; endl;\n\n\t&#x2F;&#x2F; 显示param的类型(ParamType)\n\tcout &lt;&lt; &quot;param&#39;s type &#x3D;\\t&quot;\n\t\t&lt;&lt; type_id_with_cvr&lt;decltype(param)&gt;().pretty_name()\n\t\t&lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\tint keyVals[] &#x3D; &#123; 1,3,5,7,9 &#125;;\n\n\tf(keyVals);\n&#125;\n\n&#x2F;*\n匹配形参为T的模板函数:\nT&#39;s type &#x3D;      int *\nparam&#39;s type &#x3D;  int *\n*&#x2F;\n形参为引用传递的模板：\n#include &lt;boost&#x2F;type_index.hpp&gt;\n#include &lt;iostream&gt;\n\ntemplate&lt;typename T&gt;\nvoid f(T&amp; param) &#123;\n\tusing std::cout;\n\tusing std::endl;\n\tusing boost::typeindex::type_id_with_cvr;\n\n\tcout &lt;&lt; &quot;匹配形参为T&amp;的模板函数:&quot; &lt;&lt; endl;\n\t&#x2F;&#x2F; 显示T的类型\n\tcout &lt;&lt; &quot;T&#39;s type &#x3D;\\t&quot;\n\t\t&lt;&lt; type_id_with_cvr&lt;T&gt;().pretty_name()\n\t\t&lt;&lt; endl;\n\n\t&#x2F;&#x2F; 显示param的类型(ParamType)\n\tcout &lt;&lt; &quot;param&#39;s type &#x3D;\\t&quot;\n\t\t&lt;&lt; type_id_with_cvr&lt;decltype(param)&gt;().pretty_name()\n\t\t&lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\tint keyVals[] &#x3D; &#123; 1,3,5,7,9 &#125;;\n\n\tf(keyVals);\n&#125;\n\n&#x2F;*\n匹配形参为T&amp;的模板函数:\nT&#39;s type &#x3D;      int [5]\nparam&#39;s type &#x3D;  int (&amp;)[5]\n*&#x2F;\n可利用引用传递保留数组属性这一点，结合非类型模板参数，推导出数组元素个数。\ntemplate&lt;typename T, std::size_t N&gt;\nconstexpr std::size_t arraySize(T(&amp;)[N]) noexcept &#123;\n\treturn N;\n&#125;\n\nint main() &#123;\n\tusing std::cout;\n\tusing std::endl;\n\tint keyVals[] &#x3D; &#123; 1,3,5,7,9 &#125;;\n\n\tcout &lt;&lt; arraySize(keyVals) &lt;&lt; endl;\n&#125;\n\n&#x2F;*\n执行结果：\n5\n*&#x2F;\n特殊情况2：函数实参\n当函数传给按值或引用形参的模板时，函数会退化为函数指针或函数引用。#include &lt;boost&#x2F;type_index.hpp&gt;\n#include &lt;iostream&gt;\n\nvoid someFunc(int, double) &#123;&#125;\n\ntemplate&lt;typename T&gt;\nvoid f1(T param) &#123;\n\tusing std::cout;\n\tusing std::endl;\n\tusing boost::typeindex::type_id_with_cvr;\n\n\tcout &lt;&lt; &quot;匹配形参为T的模板函数:&quot; &lt;&lt; endl;\n\t&#x2F;&#x2F; 显示T的类型\n\tcout &lt;&lt; &quot;T&#39;s type &#x3D;\\t&quot;\n\t\t&lt;&lt; type_id_with_cvr&lt;T&gt;().pretty_name()\n\t\t&lt;&lt; endl;\n\n\t&#x2F;&#x2F; 显示param的类型(ParamType)\n\tcout &lt;&lt; &quot;param&#39;s type &#x3D;\\t&quot;\n\t\t&lt;&lt; type_id_with_cvr&lt;decltype(param)&gt;().pretty_name()\n\t\t&lt;&lt; endl;\n&#125;\n\ntemplate&lt;typename T&gt;\nvoid f2(T&amp; param) &#123;\n\tusing std::cout;\n\tusing std::endl;\n\tusing boost::typeindex::type_id_with_cvr;\n\n\tcout &lt;&lt; &quot;匹配形参为T&amp;的模板函数:&quot; &lt;&lt; endl;\n\t&#x2F;&#x2F; 显示T的类型\n\tcout &lt;&lt; &quot;T&#39;s type &#x3D;\\t&quot;\n\t\t&lt;&lt; type_id_with_cvr&lt;T&gt;().pretty_name()\n\t\t&lt;&lt; endl;\n\n\t&#x2F;&#x2F; 显示param的类型(ParamType)\n\tcout &lt;&lt; &quot;param&#39;s type &#x3D;\\t&quot;\n\t\t&lt;&lt; type_id_with_cvr&lt;decltype(param)&gt;().pretty_name()\n\t\t&lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\tf1(someFunc);\n\tf2(someFunc);\n&#125;\n\n&#x2F;*\n匹配形参为T的模板函数:\nT&#39;s type &#x3D;      void (__cdecl*)(int,double)\nparam&#39;s type &#x3D;  void (__cdecl*)(int,double)\n匹配形参为T&amp;的模板函数:\nT&#39;s type &#x3D;      void __cdecl(int,double)\nparam&#39;s type &#x3D;  void (__cdecl&amp;)(int,double)\n*&#x2F;\n\n\n","slug":"模板类型推导","date":"2022-01-03T12:32:36.000Z","categories_index":"C++","tags_index":"C++,template,类型推导","author_index":"Dylan"},{"id":"28e8be842274bcbbc24c76b0de30d4ae","title":"UE4-GAS","content":"AbilitySystemComponentASC提供了三种不同的复制模式，用以复制GameplayEffects、GameplayTags 和 GameplayCues，分别是Full, Mixed, 和 Minimal。Attributes是由 AttributeSet复制。\n\n\n\n复制模式\n使用场景\n描述\n\n\n\nFull\n单人\nGameplayEffect会被复制到所有客户端。\n\n\nMixed\n多人,玩家控制的Actors\nGameplayEffects仅被复制到拥有者的客户端. 仅 GameplayTags 和 GameplayCues 会被复制到所有客户端\n\n\nMinimal\n多人, AI控制的Actors\nGameplayEffects不会复制到任何客户端. 仅 GameplayTags 和 GameplayCues 会被复制到所有客户端\n\n\n注意： Mixed 复制模式要求OwnerActor的 Owner必须是Controller。 PlayerState的 Owner默认是Controller，但是Character不是。如果使用Mixed复制模式的OwnerActor不是PlayerState那么你需要在OwnerActor上调用SetOwner()并传递一个有效的Controller。（不过从4.24开始, PossessedBy() 会为Pawn设置一个新的Controller。）\nASC需要有OwnerActor和AvatarActor进行初始化，而且必须在服务器和客户端都要完成初始化。\n对于玩家控制的角色，ASC存在于Pawn中，我通常在Pawn的 PossessedBy()方法中完成ASC在服务器端的初始化，在PlayerController的AcknowledgePawn()方法中完成ASC在客户端的初始化。\n对于玩家控制的角色，ASC存在于PlayerState中，我通常在Pawn 的PossessedBy() 方法中完成ASC在服务器端的初始化（这一点与上述相同），在 Pawn的 OnRep_PlayerState()方法中完成ASC在客户端的初始化（这将确保PlayerState在客户端已存在）\nGameplayTags(前面多花精力想好结构和名字，这玩意尽可能的不要在后面改)多个GameplayTags可以被存储到FGameplayTagContainer中。强烈建议使用GameplayTagContainer而不是TArray&lt;FGameplayTag&gt;，因为GameplayTagContainers添加了一些例其高效的魔法。 标签是标准的FNames，在FGameplayTagContainers中他们可以被高效的打包在一起以完成网络复制，当然需要先在项目设置中开启Fast Replication。Fast Replication要求服务器和客户端拥有相同的GameplayTags列表。为了遍历GameplayTagContainers也可以返回一个TArray&lt;FGameplayTag&gt;。\nASC 也可以添加不会被复制并且需要手动管理的LooseGameplayTags。\n","slug":"UE4-GAS","date":"2022-01-03T08:02:28.000Z","categories_index":"UE4","tags_index":"UE4,GAS","author_index":"Dylan"}]