{"title":"auto类型推导","uid":"f7cb7d701b00fc37f4d06f66b3862db0","slug":"Cpp-auto类型推导","date":"2022-01-04T15:25:31.000Z","updated":"2022-01-04T16:07:26.260Z","comments":true,"path":"api/articles/Cpp-auto类型推导.json","keywords":"C++,python,图形学,UE4,leetcode","cover":"https://s2.loli.net/2022/01/03/eukLiQmY5qfdhns.jpg","content":"<h1 id=\"auto类型推导\"><a href=\"#auto类型推导\" class=\"headerlink\" title=\"auto类型推导\"></a>auto类型推导</h1><p><strong>一般情况，auto类型推导和<a href=\"https://otakudylan.github.io/post/Cpp_%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC\">模板类型推导</a>是一模一样的，但是auto类型推导会假定用大括号括起来的初始化表达式代表一个<code>std::initializer_list</code>,而这种情况下，形参为T的模板无法推导T的类型。</strong></p>\n<h2 id=\"一般情况\"><a href=\"#一般情况\" class=\"headerlink\" title=\"一般情况\"></a>一般情况</h2><p>auto类型推导和模板类型推导可以建立一一映射：</p>\n<p>模板类型推导形参T&amp;：</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">template&lt;typename T&gt;\nvoid f(T&amp; param);\n\nf(expr);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>auto类型推导对应的形式：</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">auto&amp; param &#x3D; expr; &#x2F;&#x2F; auto这里和模板类型推导的T对应。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<hr>\n<p>模板类型推导形参const T&amp;：</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">template&lt;typename T&gt;\nvoid f(const T&amp; param);\n\nf(expr);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>auto类型推导对应的形式：</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">const auto&amp; param &#x3D; expr; <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<hr>\n<p>模板类型推导形参万能引用T&amp;&amp;：</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">template&lt;typename T&gt;\nvoid f(T&amp;&amp; param);\n\nf(expr);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>auto类型推导对应的形式：</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">auto&amp;&amp; param &#x3D; expr; <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h2 id=\"特殊情况\"><a href=\"#特殊情况\" class=\"headerlink\" title=\"特殊情况\"></a>特殊情况</h2><p>auto类型推导会假定用大括号括起来的初始化表达式代表一个<code>std::initializer_list</code>,而这种情况下，形参为T的模板无法推导T的类型。<br>auto类型推导为<code>std::initializer_list</code>。</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">auto x &#x3D; &#123; 1,2,3,4 &#125;;\ncout &lt;&lt; &quot;x&#39;s type &#x3D;\\t&quot;\n    &lt;&lt; type_id_with_cvr&lt;decltype(x)&gt;().pretty_name()\n    &lt;&lt; endl;\n&#x2F;&#x2F; 输出:\n&#x2F;&#x2F; x&#39;s type &#x3D;      class std::initializer_list&lt;int&gt;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>模板类型推导，编译报错。</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">#include &lt;boost&#x2F;type_index.hpp&gt;\n#include &lt;iostream&gt;\n\nusing std::cout;\nusing std::endl;\nusing boost::typeindex::type_id_with_cvr;\n\ntemplate&lt;typename T&gt;\nvoid f(T param) &#123;\n\t\n\tcout &lt;&lt; &quot;匹配形参为T的模板函数:&quot; &lt;&lt; endl;\n\t&#x2F;&#x2F; 显示T的类型\n\tcout &lt;&lt; &quot;T&#39;s type &#x3D;\\t&quot;\n\t\t&lt;&lt; type_id_with_cvr&lt;T&gt;().pretty_name()\n\t\t&lt;&lt; endl;\n\n\t&#x2F;&#x2F; 显示param的类型(ParamType)\n\tcout &lt;&lt; &quot;param&#39;s type &#x3D;\\t&quot;\n\t\t&lt;&lt; type_id_with_cvr&lt;decltype(param)&gt;().pretty_name()\n\t\t&lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\tf(&#123; 1,2,3,4 &#125;);\n&#125;\n\n&#x2F;*\n编译报错：\nerror C2672: &#39;f&#39;: no matching overloaded function found\nerror C2783: &#39;void f(T)&#39;: could not deduce template argument for &#39;T&#39;\nmessage : see declaration of &#39;f&#39;\n*&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"C-14的两种特殊情况\"><a href=\"#C-14的两种特殊情况\" class=\"headerlink\" title=\"C++14的两种特殊情况\"></a>C++14的两种特殊情况</h2><p><strong>C++14允许使用auto来说明函数返回值需要推导，lambda式也会在形参声明中用到auto，但是这两种情况是使用模板类型推导，也即不支持推导类型为<code>std::initializer_list</code>。</strong><br>这两种情况编译不过：</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">auto createInitList() &#123;\n    return &#123;1, 2, 3&#125;; \n&#125;\n&#x2F;*\n错误：\nerror C3108: cannot deduce a type as an initializer list is not an expression\nerror C2440: &#39;return&#39;: cannot convert from &#39;initializer list&#39; to &#39;auto&#39;\n*&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">std::vector&lt;int&gt; v;\nauto resetV &#x3D; [&amp;v](const auto&amp; newValue) &#123; v &#x3D; newValue; &#125;;\nresetV(&#123;1, 2, 3&#125;);\n&#x2F;*\n错误：\nerror C2672: &#39;operator __surrogate_func&#39;: no matching overloaded function found\nerror C2783: &#39;auto main::&lt;lambda_54107a7a2c8ad00836a27f4efe579f91&gt;::operator ()(const _T1 &amp;) const&#39;: could not deduce template argument for &#39;_T1&#39;\n*&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","feature":true,"text":"auto类型推导一般情况，auto类型推导和模板类型推导是一模一样的，但是auto类型推导会假定用大括号括起来的初始化表达式代表一个std::initializer_list,而这种情况下，形参为T的模板无法推导T的类型。 一般情况auto类型推导和模板类型推导可以建立一一映射：...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"C++","slug":"C","count":2,"path":"api/categories/C.json"}],"tags":[{"name":"C++","slug":"C","count":2,"path":"api/tags/C.json"},{"name":"auto","slug":"auto","count":1,"path":"api/tags/auto.json"},{"name":"类型推导","slug":"类型推导","count":2,"path":"api/tags/类型推导.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#auto%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC\"><span class=\"toc-text\">auto类型推导</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E8%88%AC%E6%83%85%E5%86%B5\"><span class=\"toc-text\">一般情况</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5\"><span class=\"toc-text\">特殊情况</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#C-14%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5\"><span class=\"toc-text\">C++14的两种特殊情况</span></a></li></ol></li></ol>","author":{"name":"Dylan","slug":"blog-author","avatar":"https://s2.loli.net/2022/01/02/Uh28kIuHP3TD4tc.jpg","link":"/","description":"No Game No Life","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"模板类型推导","uid":"74bd91e54bf2c495459c34d0d276fa06","slug":"Cpp_模板类型推导","date":"2022-01-03T12:32:36.000Z","updated":"2022-01-03T15:16:07.220Z","comments":true,"path":"api/articles/Cpp_模板类型推导.json","keywords":"C++,python,图形学,UE4,leetcode","cover":"https://s2.loli.net/2022/01/03/eukLiQmY5qfdhns.jpg","text":"类型推导C++是静态类型语言，所有的类型推导都是在编译期间完成的。 模板类型推导函数模板调用的一般形式为： template&lt;typename T&gt; void f(ParamType param); f(expr); 类型推导一共分三种一般情况和两种特殊情况 情况1：...","link":"","photos":[],"count_time":{"symbolsCount":"8.6k","symbolsTime":"8 mins."},"categories":[{"name":"C++","slug":"C","count":2,"path":"api/categories/C.json"}],"tags":[{"name":"C++","slug":"C","count":2,"path":"api/tags/C.json"},{"name":"template","slug":"template","count":1,"path":"api/tags/template.json"},{"name":"类型推导","slug":"类型推导","count":2,"path":"api/tags/类型推导.json"}],"author":{"name":"Dylan","slug":"blog-author","avatar":"https://s2.loli.net/2022/01/02/Uh28kIuHP3TD4tc.jpg","link":"/","description":"No Game No Life","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}