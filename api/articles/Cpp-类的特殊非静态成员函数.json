{"title":"类的特殊非静态成员函数","uid":"52d648ff3e6bea3e12a567ee8b6734e9","slug":"Cpp-类的特殊非静态成员函数","date":"2022-01-05T13:04:21.000Z","updated":"2022-01-05T16:25:50.238Z","comments":true,"path":"api/articles/Cpp-类的特殊非静态成员函数.json","keywords":"C++,python,图形学,UE4,leetcode","cover":"https://s2.loli.net/2022/01/03/eukLiQmY5qfdhns.jpg","content":"<h1 id=\"类的特殊非静态成员函数\"><a href=\"#类的特殊非静态成员函数\" class=\"headerlink\" title=\"类的特殊非静态成员函数\"></a>类的特殊非静态成员函数</h1><h2 id=\"类里面存在六个特种成员函数\"><a href=\"#类里面存在六个特种成员函数\" class=\"headerlink\" title=\"类里面存在六个特种成员函数\"></a>类里面存在六个特种成员函数</h2><ol>\n<li><strong>默认构造函数</strong><br> 一般形式：<code>Obj();</code></li>\n<li><strong>拷贝构造函数</strong><br> 一般形式：<code>Obj(const Obj&amp;);</code></li>\n<li><strong>拷贝赋值运算符</strong><br>一般形式：<code>Obj&amp; operator=(const Obj&amp;);</code>或<code>Obj&amp; operator=(Obj);</code></li>\n<li><strong>移动构造函数</strong><br>一般形式：<code>Obj(Obj&amp;&amp;);</code></li>\n<li><strong>移动赋值运算符</strong><br>一般形式：<code>Obj&amp; operator=(Obj&amp;&amp;);</code></li>\n<li><strong>析构函数</strong><br>一般形式：<code>~Obj();</code></li>\n</ol>\n<p><strong>特点：</strong></p>\n<ul>\n<li>C++会隐式声明和默认提供。但是默认提供存在一定规则。</li>\n<li>成员函数模板在任何情况下都不会抑制这些函数的隐式声明和默认提供。<h2 id=\"一般规则\"><a href=\"#一般规则\" class=\"headerlink\" title=\"一般规则\"></a>一般规则</h2></li>\n</ul>\n<ol>\n<li>当用户不提供其他构造函数（包括拷贝构造和移动构造）时，<strong>默认构造函数</strong>会被隐式声明、默认提供。</li>\n<li>当用户不提供拷贝构造函数时，<strong>拷贝构造函数</strong>会被隐式声明、默认提供。</li>\n<li>当用户不提供拷贝赋值运算符时，<strong>拷贝赋值运算符</strong>会被隐式声明、默认提供。</li>\n<li>当用户不提供析构函数时，<strong>析构函数</strong>会被隐式声明、默认提供。<h2 id=\"重要规则\"><a href=\"#重要规则\" class=\"headerlink\" title=\"重要规则\"></a>重要规则</h2><img src=\"https://s2.loli.net/2022/01/05/cGiWwRo6qbExy1t.png\" alt=\"特殊非静态成员函数删除和生成规则\"></li>\n<li><strong>拷贝构造函数</strong>：当用户声明移动构造函数和移动赋值运算符时，隐式声明的拷贝构造函数会被删除。当已经存在拷贝赋值运算符或析构函数时，不建议生成拷贝构造函数。</li>\n<li><strong>拷贝赋值运算符</strong>：当用户声明移动构造函数和移动赋值运算符时，隐式声明的拷贝赋值运算符会被删除。当已经存在拷贝构造函数或析构函数时，不建议生成拷贝赋值运算符。</li>\n<li><strong>移动构造函数</strong>：当用户不声明除默认构造函数外的任意一个特殊成员函数（包含”<code>= delete</code>“的情况）时，移动构造函数会被隐式声明、默认提供。</li>\n<li><strong>移动赋值运算符</strong>：当用户不声明除默认构造函数外的任意一个特殊成员函数（包含”<code>= delete</code>“的情况）时，移动赋值运算符会被隐式声明、默认提供。<h2 id=\"惯用法\"><a href=\"#惯用法\" class=\"headerlink\" title=\"惯用法\"></a>惯用法</h2></li>\n<li><strong>默认构造函数</strong>：在用户提供其他构造函数时，使用”<code>= default</code>“要求编译器提供默认版本。</li>\n<li><strong>拷贝构造函数</strong>：使用”<code>= delete</code>“要求编译器删除默认版本，防止对象被意外复制。</li>\n<li><strong>拷贝赋值运算符</strong>：和拷贝构造函数一起定义或被删除。</li>\n<li><strong>移动构造函数</strong>：要么由编译器提供隐式声明的默认版本，要么由用户自行提供；一般不需要使用”<code>= default</code>“或”<code>= delete</code>“。</li>\n<li><strong>移动赋值运算符</strong>：要么由编译器提供隐式声明的默认版本，要么由用户自行提供；一般不需要使用”<code>= default</code>“或”<code>= delete</code>“。</li>\n<li><strong>析构函数</strong>：对于面向对象继承树的基类，使用”<code>virtual ~Obj() = default;</code>“。<h2 id=\"三-五法则\"><a href=\"#三-五法则\" class=\"headerlink\" title=\"三/五法则\"></a>三/五法则</h2></li>\n</ol>\n<p><strong>C++98三法则：</strong></p>\n<ul>\n<li>如果一个类需要自定义析构函数，几乎可以肯定它肯定也需要自定义拷贝构造函数和拷贝赋值运算符。</li>\n<li>需要拷贝操作的类也需要赋值操作，反之亦然。</li>\n<li>无论是需要拷贝构造函数还是需要拷贝赋值运算符都不必然意味着也需要析构函数。</li>\n</ul>\n<p><strong>C++11五法则：</strong></p>\n<ul>\n<li>如果一个类定义了任何一个拷贝操作，他就应该定义所有五个操作（拷贝、拷贝赋值、移动、移动赋值、析构）。</li>\n<li>因为用户定义的析构函数、复制构造函数或复制赋值运算符的存在会阻止移动构造函数和移动赋值运算符的隐式定义，所以任何想要移动语义的类必须声明全部五个特殊成员函数：</li>\n</ul>\n<p><strong>参考：</strong><br>《C++ Primer》13.1.4节（第447页）和13.6.2节（第478页）<br><a href=\"https://zh.cppreference.com/w/cpp/language/rule_of_three\">三/五/零法则</a>.</p>\n","feature":true,"text":"类的特殊非静态成员函数类里面存在六个特种成员函数 默认构造函数 一般形式：Obj(); 拷贝构造函数 一般形式：Obj(const Obj&amp;); 拷贝赋值运算符一般形式：Obj&amp; operator=(const Obj&amp;);或Obj&amp; operat...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"C++","slug":"C","count":3,"path":"api/categories/C.json"}],"tags":[{"name":"C++","slug":"C","count":3,"path":"api/tags/C.json"},{"name":"成员函数","slug":"成员函数","count":1,"path":"api/tags/成员函数.json"},{"name":"默认提供","slug":"默认提供","count":1,"path":"api/tags/默认提供.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E7%9A%84%E7%89%B9%E6%AE%8A%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">类的特殊非静态成员函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E9%87%8C%E9%9D%A2%E5%AD%98%E5%9C%A8%E5%85%AD%E4%B8%AA%E7%89%B9%E7%A7%8D%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">类里面存在六个特种成员函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E8%88%AC%E8%A7%84%E5%88%99\"><span class=\"toc-text\">一般规则</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%87%8D%E8%A6%81%E8%A7%84%E5%88%99\"><span class=\"toc-text\">重要规则</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%83%AF%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">惯用法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89-%E4%BA%94%E6%B3%95%E5%88%99\"><span class=\"toc-text\">三&#x2F;五法则</span></a></li></ol></li></ol>","author":{"name":"Dylan","slug":"blog-author","avatar":"https://s2.loli.net/2022/01/02/Uh28kIuHP3TD4tc.jpg","link":"/","description":"No Game No Life","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"auto类型推导","uid":"f7cb7d701b00fc37f4d06f66b3862db0","slug":"Cpp-auto类型推导","date":"2022-01-04T15:25:31.000Z","updated":"2022-01-04T16:07:26.260Z","comments":true,"path":"api/articles/Cpp-auto类型推导.json","keywords":"C++,python,图形学,UE4,leetcode","cover":"https://s2.loli.net/2022/01/03/eukLiQmY5qfdhns.jpg","text":"auto类型推导一般情况，auto类型推导和模板类型推导是一模一样的，但是auto类型推导会假定用大括号括起来的初始化表达式代表一个std::initializer_list,而这种情况下，形参为T的模板无法推导T的类型。 一般情况auto类型推导和模板类型推导可以建立一一映射：...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"C++","slug":"C","count":3,"path":"api/categories/C.json"}],"tags":[{"name":"C++","slug":"C","count":3,"path":"api/tags/C.json"},{"name":"auto","slug":"auto","count":1,"path":"api/tags/auto.json"},{"name":"类型推导","slug":"类型推导","count":2,"path":"api/tags/类型推导.json"}],"author":{"name":"Dylan","slug":"blog-author","avatar":"https://s2.loli.net/2022/01/02/Uh28kIuHP3TD4tc.jpg","link":"/","description":"No Game No Life","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}