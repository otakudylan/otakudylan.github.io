{"title":"UE4-GAS","uid":"28e8be842274bcbbc24c76b0de30d4ae","slug":"UE4-GAS","date":"2022-01-03T08:02:28.000Z","updated":"2022-01-05T16:15:56.290Z","comments":true,"path":"api/articles/UE4-GAS.json","keywords":"C++,python,图形学,UE4,leetcode","cover":"https://s2.loli.net/2022/01/03/Ym9bIshjoP2ER7M.jpg","content":"<h2 id=\"AbilitySystemComponent\"><a href=\"#AbilitySystemComponent\" class=\"headerlink\" title=\"AbilitySystemComponent\"></a>AbilitySystemComponent</h2><p><code>ASC</code>提供了三种不同的复制模式，用以复制<code>GameplayEffects</code>、<code>GameplayTags</code> 和 <code>GameplayCues</code>，分别是<code>Full</code>, <code>Mixed</code>, 和 <code>Minimal</code>。<code>Attributes</code>是由 <code>AttributeSet</code>复制。</p>\n<table>\n<thead>\n<tr>\n<th>复制模式</th>\n<th>使用场景</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Full</code></td>\n<td>单人</td>\n<td><code>GameplayEffect</code>会被复制到所有客户端。</td>\n</tr>\n<tr>\n<td><code>Mixed</code></td>\n<td>多人,玩家控制的<code>Actors</code></td>\n<td><code>GameplayEffects</code>仅被复制到拥有者的客户端. 仅 <code>GameplayTags</code> 和 <code>GameplayCues</code> 会被复制到所有客户端</td>\n</tr>\n<tr>\n<td><code>Minimal</code></td>\n<td>多人, AI控制的<code>Actors</code></td>\n<td><code>GameplayEffects</code>不会复制到任何客户端. 仅 <code>GameplayTags</code> 和 <code>GameplayCues</code> 会被复制到所有客户端</td>\n</tr>\n</tbody></table>\n<p><strong>注意：</strong> <code>Mixed</code> 复制模式要求<code>OwnerActor</code>的 <code>Owner</code>必须是<code>Controller</code>。 <code>PlayerState</code>的 <code>Owner</code>默认是<code>Controller</code>，但是<code>Character</code>不是。如果使用<code>Mixed</code>复制模式的<code>OwnerActor</code>不是<code>PlayerState</code>那么你需要在<code>OwnerActor</code>上调用<code>SetOwner()</code>并传递一个有效的<code>Controller</code>。（不过从4.24开始, <code>PossessedBy()</code> 会为<code>Pawn</code>设置一个新的<code>Controller</code>。）</p>\n<p><code>ASC</code>需要有<code>OwnerActor</code>和<code>AvatarActor</code>进行初始化，而且必须在服务器和客户端都要完成初始化。</p>\n<p>对于玩家控制的角色，<code>ASC</code>存在于<code>Pawn</code>中，我通常在<code>Pawn</code>的 <code>PossessedBy()</code>方法中完成<code>ASC</code>在服务器端的初始化，在<code>PlayerController</code>的<code>AcknowledgePawn()</code>方法中完成<code>ASC</code>在客户端的初始化。</p>\n<p>对于玩家控制的角色，<code>ASC</code>存在于<code>PlayerState</code>中，我通常在<code>Pawn</code> 的<code>PossessedBy()</code> 方法中完成<code>ASC</code>在服务器端的初始化（这一点与上述相同），在 <code>Pawn</code>的 <code>OnRep_PlayerState()</code>方法中完成<code>ASC</code>在客户端的初始化（这将确保<code>PlayerState</code>在客户端已存在）</p>\n<h2 id=\"GameplayTags\"><a href=\"#GameplayTags\" class=\"headerlink\" title=\"GameplayTags\"></a>GameplayTags</h2><h5 id=\"前面多花精力想好结构和名字，这玩意尽可能的不要在后面改\"><a href=\"#前面多花精力想好结构和名字，这玩意尽可能的不要在后面改\" class=\"headerlink\" title=\"(前面多花精力想好结构和名字，这玩意尽可能的不要在后面改)\"></a>(前面多花精力想好结构和名字，这玩意尽可能的不要在后面改)</h5><p>多个<code>GameplayTags</code>可以被存储到<code>FGameplayTagContainer</code>中。强烈建议使用<code>GameplayTagContainer</code>而不是<code>TArray&lt;FGameplayTag&gt;</code>，因为<code>GameplayTagContainers</code>添加了一些例其高效的魔法。 标签是标准的<code>FNames</code>，在<code>FGameplayTagContainers</code>中他们可以被高效的打包在一起以完成<strong>网络复制</strong>，当然需要先在项目设置中开启<code>Fast Replication</code>。<code>Fast Replication</code>要求服务器和客户端拥有相同的<code>GameplayTags</code>列表。为了遍历<code>GameplayTagContainers</code>也可以返回一个<code>TArray&lt;FGameplayTag&gt;</code>。</p>\n<p><code>ASC</code> 也可以添加不会被复制并且需要手动管理的<code>LooseGameplayTags</code>。</p>\n","text":"AbilitySystemComponentASC提供了三种不同的复制模式，用以复制GameplayEffects、GameplayTags 和 GameplayCues，分别是Full, Mixed, 和 Minimal。Attributes是由 AttributeSet复制。...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"UE4","slug":"UE4","count":2,"path":"api/categories/UE4.json"}],"tags":[{"name":"UE4","slug":"UE4","count":2,"path":"api/tags/UE4.json"},{"name":"GAS","slug":"GAS","count":1,"path":"api/tags/GAS.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#AbilitySystemComponent\"><span class=\"toc-text\">AbilitySystemComponent</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#GameplayTags\"><span class=\"toc-text\">GameplayTags</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%89%8D%E9%9D%A2%E5%A4%9A%E8%8A%B1%E7%B2%BE%E5%8A%9B%E6%83%B3%E5%A5%BD%E7%BB%93%E6%9E%84%E5%92%8C%E5%90%8D%E5%AD%97%EF%BC%8C%E8%BF%99%E7%8E%A9%E6%84%8F%E5%B0%BD%E5%8F%AF%E8%83%BD%E7%9A%84%E4%B8%8D%E8%A6%81%E5%9C%A8%E5%90%8E%E9%9D%A2%E6%94%B9\"><span class=\"toc-text\">(前面多花精力想好结构和名字，这玩意尽可能的不要在后面改)</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"Dylan","slug":"blog-author","avatar":"https://s2.loli.net/2022/01/02/Uh28kIuHP3TD4tc.jpg","link":"/","description":"No Game No Life","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"模板类型推导","uid":"74bd91e54bf2c495459c34d0d276fa06","slug":"Cpp-模板类型推导","date":"2022-01-03T12:32:36.000Z","updated":"2022-01-05T16:15:49.129Z","comments":true,"path":"api/articles/Cpp-模板类型推导.json","keywords":"C++,python,图形学,UE4,leetcode","cover":"https://s2.loli.net/2022/01/03/eukLiQmY5qfdhns.jpg","text":"类型推导C++是静态类型语言，所有的类型推导都是在编译期间完成的。 模板类型推导函数模板调用的一般形式为： template&lt;typename T&gt; void f(ParamType param); f(expr); 类型推导一共分三种一般情况和两种特殊情况 情况1：...","link":"","photos":[],"count_time":{"symbolsCount":"8.6k","symbolsTime":"8 mins."},"categories":[{"name":"C++","slug":"C","count":5,"path":"api/categories/C.json"}],"tags":[{"name":"C++","slug":"C","count":5,"path":"api/tags/C.json"},{"name":"template","slug":"template","count":1,"path":"api/tags/template.json"},{"name":"类型推导","slug":"类型推导","count":2,"path":"api/tags/类型推导.json"}],"author":{"name":"Dylan","slug":"blog-author","avatar":"https://s2.loli.net/2022/01/02/Uh28kIuHP3TD4tc.jpg","link":"/","description":"No Game No Life","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{}}